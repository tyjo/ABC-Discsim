import ercs
import multiprocessing
import subprocess as sub
import src.newick_conversion as newick
from random import randint
from settings import settings
from src.seqgen import run_seqgen
from src.alrq import convert_to_arp
from src.validate_settings import validate

class ErcsSimulation(ercs.Simulator):
	def setup(self, sample, event_classes):
		self.sample = [None] + sample
		self.event_classes = event_classes

	def generate_tree_data(self, seed):
		pi, tau = self.run(seed)
		return pi, tau

def make_trees(tree_data):
	'''
	Takes pi and tau from the replicates generated by run_replicates
	Converts them to Newick Tree Format
	Returns list of trees.
	'''
	pi = tree_data[0]
	tau = tree_data[1]
	trees = []
	for i, j in zip(pi, tau):
		trees.append(newick.convert_tree(i, j))
	return trees

def generate_event_parameters(event, num_replicates):
	rate = [randint(event['rate'][0], event['rate'][1])/float(1000) \
		for i in range(num_replicates)]
	radius = [randint(event['radius'][0], event['radius'][1]) \
		for j in range(num_replicates)]
	events = []
	for r1, r2 in zip(rate, radius):
		events.append((r1, r2))
	return events

def subprocess_worker(t):
	'''
	Runs a single simulation using ERCS and calls Seq-Gen to
	generate the DNA sequence.
	'''
	sim, seed, seq_gen_seeds, scales, sample, small_rate, small_radius, \
		large_rate, large_radius = t
	small_event = ercs.DiscEventClass(rate=small_rate, \
		r=small_radius, u=settings['small_event']['u'])
	large_event = ercs.DiscEventClass(rate=large_rate, r=large_radius, \
		u=settings['large_event']['u'])
	events = [large_event]
	sim.setup(sample, events)
	
	# Seq-Gen Simulation Parameters
	seq_length = settings['seq_length']
	partition_lengths = settings['partitions']
	num_partitions = settings['num_partitions']

	# Save file in Newick Tree Format
	tree_data = sim.generate_tree_data(seed)
	
	try:
		trees = make_trees(tree_data)
	except:
		with open("errors.txt", "a") as f:
			f.write("Nonterminating recursion\n" + str(tree_data) + "\n")
	
	filename = "tree_" + str(seed)
	num_tree = 1
	for tree in trees:
		with open(filename + "_" + str(num_tree), "w") as f:
			num_tree += 1
			f.write(str(tree) + "\n")
	
	# Calls SeqGen
	seqgen_sequences = run_seqgen(seed, seq_gen_seeds)

	with open("DNA_" + str(seed), "w") as f:
		f.write("Scaled mutation rate for each loci {}\n".format(scales))
		for seq in seqgen_sequences:
			sequence = "\t".join(seqgen_sequences[seq])
			f.write("{0}\t{1}\n".format(seq, sequence))


	nonbifurcation = convert_to_arp(seed, seqgen_sequences, scales)

	if nonbifurcation == True:
		with open("errors.txt", "a") as f:
			f.write("nonbifurcation\n")
			f.write(str(seed) + "\n")
			f.write(str(tree_data) + "\n")

	# File cleanup
	for i in range(1, num_tree):
		sub.call(["rm", filename + "_" + str(i)])
		sub.call(["rm", "DNA_" + str(seed) + "_" + str(i)])

	sub.call(["rm", "DNA_" + str(seed)])

def run_replicates(sim, num_replicates, sample, events, worker_pool):
	small_rate = []
	small_radius = []
	large_rate = []
	large_radius = []

	# Build small events
	for event in events['small_events']:
		small_rate.append(event[0])
		small_radius.append(event[1])

	# Build large events
	for event in events['large_events']:
		large_rate.append(event[0])
		large_radius.append(event[1])


	# Generate random seeds
	ercs_seeds = [randint(1, 2**31) for j in range(num_replicates)]
	seq_gen_seeds = [[randint(1, 2**31) for j in \
	  range(int(settings["num_partitions"]))] for i in range(num_replicates)]

	# Scale to mutation rate
	num_partitions = settings['num_partitions']
	scale = settings['mutation_rate']
	evolution_rate = []
	for rate in settings['evolution_rates']:
		evolution_rate.append(scale * rate)
	
	scales = []
	for j in range(num_replicates):
		scales.append(evolution_rate[:])

	with open("errors.txt", "w") as f:
		f.write("Errors\n")

	with open("parameters.txt", "w") as f:
		seed_rate = {}
		f.write('seed\tsmall_rate\tsmall_radius\tlarge_rate\tlarge_radius\n')
		for seed, r1, r2, r3, r4 in zip(ercs_seeds, small_rate, small_radius, large_rate, large_radius):
			seed_rate[str(seed)] = (r1, r2, r3, r4)

		# Need to sort by string value to have same ordering as Arlequin
		for seed in sorted(seed_rate):
			f.write("{}\t{}\t{}\t{}\t{}\n".format(seed, seed_rate[seed][0], seed_rate[seed][1], \
				seed_rate[seed][2], seed_rate[seed][3]))

	args = [(sim, ercs_seeds[j], seq_gen_seeds[j], scales[j], sample, 
		small_rate[j], small_radius[j], large_rate[j], large_radius[j]) for j in range(num_replicates)]
	
	# Use this when running simulations
	replicates = worker_pool.map(subprocess_worker, args)
	
	#Use this for testing
	#for arg in args:
	#	subprocess_worker(arg)

def run_simulations(recombination_probabilities = None):
	'''
	Set up ERCS specific variables.
	'''
	num_replicates = settings['num_replicates']
	landscape_size = settings['landscape_size']
	sample_locations = settings['sample_locations']
	small_events = generate_event_parameters(settings['small_event'], num_replicates)
	large_events = generate_event_parameters(settings['large_event'], num_replicates)

	events = {'small_events': small_events, 'large_events': large_events}
	
	# Initialize simulator
	sim = ErcsSimulation(landscape_size)
	sim.recombination_probabilities = settings['recombination_probabilities']


	# Multiprocessing parameters
	if settings['num_cpus'] == 0:
		processes = multiprocessing.cpu_count()
	else:
		processes = settings['num_cpus']
	workers = multiprocessing.Pool(processes=processes, maxtasksperchild=1000)
	
	run_replicates(sim, num_replicates, sample_locations, events, workers)

if __name__ == "__main__":
	print "Loading settings..."
	print "Validating settings file..."
	validate()
	print "Starting simulations..."
	run_simulations()

	for i in range(10):
		for j in range(10):
			sub.call("mv DNA_{}{}* output_sequences/ &> /dev/null &".format(str(i), str(j)), shell=True)
			sub.call("mv ARQ_abc_{}{}* arlsumstat_files/ &> /dev/null &".format(str(i), str(j)), shell=True)

	print "Done!"


