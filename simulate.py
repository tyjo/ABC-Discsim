import discsim
import ercs
import math
import multiprocessing
import random
import subprocess as sub
import src.newick_conversion as newick
import time
from settings import settings
from src.seqgen import run_seqgen
from src.arlq import convert_to_arp
from src.validate_settings import validate


class Simulator(discsim.Simulator):
    def setup(self, event_classes):
        """
        Set simulation parameters
        """
        self.sample = [None] + settings["sample_locations"]
        self.event_classes = event_classes
        self.recombination_probability = settings["recombination_probability"]
        self.num_loci = int(settings["num_partitions"])

    def run_simulation(self, seed, seq_gen_seeds):
        """
        Runs a single simulation. Converts simulation output to
        newick format. Runs Seq-Gen with newick trees to generate
        DNA sequence data. Returns dictionary of DNA sequences for
        each sample.
        """
        self.random_seed = seed
        self.run()
        result = self.get_history()
        self.reset()

        # Save file in Newick Tree Format
        trees = self._make_trees(result)
        
        filename = "tree_" + str(seed)
        num_tree = 1
        for tree in trees:
            with open(filename + "_" + str(num_tree), "w") as f:
                num_tree += 1
                f.write(str(tree) + "\n")
        
        # Call SeqGen
        seqgen_sequences = self._run_seqgen(seed, seq_gen_seeds)

        with open("DNA_" + str(seed), "w") as f:
            f.write("Mutation rate for each loci {}\n".format(settings["mutation_rate"]))
            for seq in seqgen_sequences:
                sequence = "\t".join(seqgen_sequences[seq])
                f.write("{0}\t{1}\n".format(seq, sequence))

        # File cleanup
        for i in range(1, num_tree):
        #    sub.call(["rm", filename + "_" + str(i)])
            sub.call(["rm", "DNA_" + str(seed) + "_" + str(i)])

        sub.call(["mv", "DNA_" + str(seed), "output_sequences/"])
        return seqgen_sequences

    def _make_trees(self, oriented_trees):
        """
        Takes pi and tau from the replicates generated by run_replicates
        Converts them to Newick Tree Format.
        Returns list of trees.
        """
        pi = oriented_trees[0]
        tau = oriented_trees[1]
        trees = []

        for i, j in zip(pi, tau):
            # convert simulation time to generation time
            j = self._rescale_coalescent_times(j)

            # sometimes an extra 0L and 0.0 are added on to
            # pi and tau respectively which breaks the newick script.
            # the tree is otherwise correct
            while(j[-1] == 0.0):
                i.pop(-1)
                j.pop(-1)

            trees.append(newick.convert_tree(i, j))
        return trees

    def _run_seqgen(self, seed, seq_gen_seeds):
        """
        Generates DNA sequences using HKY mutation model from newick trees.
        """
        filename = "tree_" + str(seed)
        partition_lengths = settings["partitions"][:]
        num_tree = int(settings["num_partitions"])
        for tree in range(1, num_tree + 1):
            i = tree - 1
            sub.call("./seqgen/seq-gen -mHKY -t2 -f0.35,0.15,0.25,0.25 -op -l{0} -s{1} -z{2} < {3}_{4} \
                > DNA_{5}_{4}".format(\
                            settings["partitions"][i], settings["mutation_rate"],
                            str(seq_gen_seeds[i]), filename, str(tree), str(seed)),
                        shell=True)

        sequences = {}
        for j in range(1, num_tree + 1):
            with open("DNA_" + str(seed) + "_" + str(j)) as f:
                lines = f.readlines()
                for line in lines[1:]:
                    line.strip('\n')
                    split = line.split()
                    if split[0] in sequences:
                        sequences[split[0]].append(split[1])
                    else:
                        sequences[split[0]] = [split[1]]

        return sequences

    def _rescale_coalescent_times(self, tau):
        """
        Rescales coalescent times from simulation time
        to generation time.
        """
        event = self.event_classes[0] # reproduction events
        return map(lambda x: x * event.rate * event.u * math.pi * event.r**2, tau)


def generate_event_parameters(num_replicates):
    """
    Make parameter sets for simulations, write to output file.
    """
    def population_density_parameter_set():
        seed = random.randint(1, 2**31 - 1)
        seq_gen_seeds = [random.randint(1, 2**31 - 1) for i in range(int(settings["num_partitions"]))]
        rate = settings["small_event"]["rate"]
        radius = settings["small_event"]["radius"]
        pop_size = random.randint(settings["population_size"][0], settings["population_size"][1])
        u0 = (2 * settings["length"]**2) / ( pop_size * math.pi * radius**2 )
        event_classes = [  ercs.DiscEventClass(rate = rate, r = radius, u = u0) ]
        return (seed, seq_gen_seeds, event_classes, pop_size)

    def extinction_rate_parameter_set():
        seed = randint(1, 2**31)
        seq_gen_seeds = [random.randint(1, 2**31 - 1) for i in range(int(settings["num_partitions"]))]
        large_rate = random.randint(settings["large_event"]["rate"][0], settings["large_event"]["rate"][1])/1000.0
        large_radius = random.randint(settings["large_event"]["radius"][0], settings["large_event"]["radius"][1])
        u0 = (2 * settings["length"]**2) / (settings['population_size'][0] * math.pi * large_radius**2)
        small_rate = settings["small_event"]["rate"]
        small_radius = settings["small_event"]["radius"]
        u1 = (2* settings["length"]**2) / (settings["population_size"][0] * math.pi * small_radius**2)
        event_classes = [ ercs.DiscEventClass(rate = small_rate, r = small_radius, u = u1),
                          ercs.DiscEventClass(rate = large_rate, r = large_radius, u = u0)]
        # need to have same number of parameters as above, 0 is unused.
        return (seed, seq_gen_seeds, event_classes, 0)
    
    random.seed()
    if(settings["estimate_population_size"]):
        parameters = [ population_density_parameter_set() for i in xrange(num_replicates) ]

        filename = "parameters_{}_{}.txt".format(time.strftime("%x"), time.strftime("%X"))
        filename = filename.replace("/","_").replace(":","")
        with open(filename, "w") as f:
            seed_parameters = {}
            f.write("seed\trate\tradius\tu\tpop_size\n")
            for seed, seq_gen_seeds, event_classes, pop_size in parameters:
                event = event_classes[0]
                seed_parameters[str(seed)] = (event.rate, event.r, event.u, pop_size)
            # Need to sort by string value to have same ordering as Arlequin
            for seed in sorted(seed_parameters):
                f.write("{}\t{}\t{}\t{}\t{}\n".format(seed, seed_parameters[seed][0], seed_parameters[seed][1],
                                                            seed_parameters[seed][2], seed_parameters[seed][3]))

    else:
        parameters = [ extinction_rate_parameter_set() for i in xrange(num_replicates) ]

        filename = "parameters_{}_{}.txt".format(time.strftime("%x"), time.strftime("%X"))
        filename = filename.replace("/","_").replace(":","")
        with open(filename, "w") as f:
            seed_parameters = {}
            f.write("seed\tlarge_rate\tlarge_radius\tu0\tsmall_rate\tsmall_radius\tu1\n")
            for seed, seq_gen_seeds, event_classes in parameters:
                small_event = event_classes[0]
                large_event = event_classes[1]
                seed_parameters[str(seed)] = (large_event.rate, large_event.r, large_event.u,
                                              small_event.rate, small_event.r, small_event.u)
            # Need to sort by string value to have same ordering as Arlequin
            for seed in sorted(seed_parameters):
                f.write("{}\t{}\t{}\t{}\t{}\t{}\t{}\t".format(seed, seed_parameters[seed][0], seed_parameters[seed][1],
                                                                    seed_parameters[seed][2], seed_parameters[seed][3],
                                                                    seed_parameters[seed][4], seed_parameters[seed][5]))

    return parameters



def subprocess_worker(t):
    """
    Runs a single simulation.
    """
    # pop_size is unused here
    seed, seq_gen_seeds, event_classes, pop_size = t

    sim = Simulator(settings["length"])
    sim.setup(event_classes)
    seqgen_sequences = sim.run_simulation(seed, seq_gen_seeds)

    nonbifurcation = convert_to_arp(seed, seqgen_sequences)

    if nonbifurcation == True:
        with open("errors.txt", "a") as f:
            f.write("nonbifurcation\n")
            f.write(time.strftime("%X") + "\n")
            f.write(str(seed) + "\n")
            f.write(str(tree_data) + "\n")



def run_simulations():
    # Multiprocessing parameters
    if settings["num_cpus"] == 0:
        processes = multiprocessing.cpu_count()
    else:
        processes = settings["num_cpus"]

    workers = multiprocessing.Pool(processes=processes, maxtasksperchild=1000)
    args = generate_event_parameters(settings["num_replicates"])
    
    # use for running simulations
    #replicates = workers.map(subprocess_worker, arg)
    
    #Use this for testing
    for arg in args:
        subprocess_worker(arg)



if __name__ == "__main__":
    print "Loading settings..."
    print "Validating settings file..."
    validate()
    print "Starting simulations..."
    start_time = time.strftime("%X")
    run_simulations()

    for i in range(10):
        for j in range(10):
            sub.call("mv ARQ_abc_{}{}* arlsumstat_files/ &> /dev/null &".format(str(i), str(j)), shell=True)

    print "Done!"
    print "Start Time: " + start_time
    print "Stop Time: " + time.strftime("%X")



